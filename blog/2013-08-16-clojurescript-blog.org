#+TITLE: clojurescript-blog
#+DATE: 2013-08-16
#+SETUPFILE: ~/src/blog-stuff/blog/setup.org
#+JEKYLL_LAYOUT: post
#+JEKYLL_CATEGORIES: hacking,clojurescript
#+JEKYLL_PUBLISHED: true
#+JEKYLL_COMMENTSISSUEID: 2

* Abstract

I've never been very good at blogging, for many, many reasons. Perhaps
one of them was just that it didn't sound interesting to me. Maybe if
there was a way to incorporate something I am really "into" - like
clojure! - into my blog, I would have more fun doing it, and do it
more.

{{{more}}}

* Introduction

Several years ago, I learned that you can run a blog from a github
account. I immediately upgraded to a paid account...and then
never really got around to actually blogging from github. Maybe I am
too lazy...or maybe I just hadn't figured out a way to incorporate
into my blogging idea anything that really interests me.

I really love programming in clojure. I have a lot of experience
programming in javascript (let's just say, I remember being scared
that I was going to be jobless when I saw all the cool things you
could do with "DHTML" (does anyone even say that anymore?) and
javascript when IE_4_ came out,) but I've never really enjoyed
javascript. It misses the mark with me on so many fundamental things
I want in a programming language. There are certainly things I like
about it, but it has almost as many quirks as C--, and I can't even
look at the disassembly.

I ran into a problem the other day trying to incorporate github
comments into my blog. I had to dig into the javascript to figure it
out[fn:1]. It was a simple problem, but...come on. What a stupid
problem to have to run into. The github API is *so* cool and...and
*this* is how we use it. I think this is why we can't have nice
*things.

How about I rewrite some of this javascript in clojurescript? I can
do it right. Proper namespaces. High order programming. Macros, if I
need them. Sane state. Maybe I can even use core.async! Hells yeah!
Let's go!

Note to squeamish readers: if you are thinking "core.async...for a
blog?! o_O", this blog post probably isn't for you. Move along
now. Go back to reading little snippets of what other people did on
hacker news. This blog post is about a full blown, geeky, insane,
anti-pragmatic, technology bender-trip. I don't even know if *I* am
going to make it back alive. I can't vouch for your safety, and if
you are not down for this type of thing, it's best that we part ways
now before someone gets hurt. C ya!

* Methods

** How the blog works

Octopress.

Source is in 'source' directory.

'_includes' get included
in templates for different types of pages.

Source is all on 'source'
branch. I write drafts on branches and merge them into source when I
want to "publish" them.

You run `rake deploy', it builds the website into a directory called
`_deploy', checks it in as branch master, which is what github is
setup to render.

I write the blog posts in org-mode because I like it. I use an emacs
plugin, org-octopress[fn:2], which let's me publish org-posts into
octopress-friendly HTML with YAML front-matter.

** What's the client-side code look like now?

All the javascript in the blog website now is either in templates
(i.e. script blocks that get included into the page) or src'd in from
the javascripts folder or from other places. I am slightly offended by
how messy it is, with different plugins adding their own dependencies,
and libraries that have identically named functions as other libraries
"for compatibility." Not trying to be critical (hell, it was
free...what's to complain about), but this kind of thing really turns
me off.

** How can we do better?

Let's create a new leiningen project. I thought I remember reading
about some cool new leiningen template that would create a project
that had everything all set up for you, but a quick google search
yields nothing like what I want: I just want to do clojurescript, no
ring, no website, no server side stuff. Why am I even bothering to
look, this is so simple.

#+name: create the project
#+BEGIN_SRC sh
# in my blog's source directory
$ lein new script
...
$ $EDITOR scripts/project.clj
#+END_SRC

#+name: touch up the project file and add lein-cljsbuild plugin
#+BEGIN_SRC clojure
(defproject scripts "0.1.0-SNAPSHOT"
  :description "Client side code for my blog"
  :url "http://cbilson.github.com/cbilson.github.com/"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.5.1"]
                 [org.clojure/clojurescript "0.0-1820"]]
  :plugins [[lein-cljsbuild "0.3.2"]]
  :cljsbuild
  {:builds
   [{:source-paths ["src-cljs"]
     :compiler
     {:output-to "../javascripts/site.js"
      :optimizations :whitespace
      :pretty-print true}}]})
#+END_SRC

Let's replace the script block I was mad at earlier

#+name: before: the script block I was mad at
#+BEGIN_EXAMPLE
<script type="text/javascript" src="http://datejs.googlecode.com/svn/trunk/build/date-en-US.js"></script>

<script type="text/javascript">

  function loadComments(data) {
    for (var i=0; i<data.length; i++) {
      var cuser = data[i].user.login;
      var cuserlink = "https://www.github.com/" + data[i].user.login;
      var clink = "https://github.com/cbilson/cbilson.github.com/issues/{{page.commentIssueId}}#issuecomment-"
                                 + data[i].url.substring(data[i].url.lastIndexOf("/")+1);
      var cbody = data[i].body_html;
      var cavatarlink = data[i].user.avatar_url;
      var cdate = Date.parse(data[i].created_at).toString("yyyy-MM-dd HH:mm:ss");

      $("#comments").append("<div class='comment'><div class='commentheader'><div class='commentgravatar'>"
                                 + '<img src="' + cavatarlink + '" alt="" width="20" height="20">'
                                 + "</div><a class='commentuser' href=\""+ cuserlink + "\">"
                                 + cuser + "</a> on <a class='commentdate' href=\"" + clink + "\">"
                                 + cdate + "</a> said:</div><div class='commentbody'>" + cbody + "</div></div>");
    }
  }

  $.ajax({url:'https://api.github.com/repos/cbilson/cbilson.github.com/issues/{{page.commentIssueId}}/comments',
          headers: {Accept: "application/vnd.github.full+json"},
          type: "json",
          success: loadComments});
</script>
#+END_EXAMPLE

#+name: after: the script rewritten in clojurescript
#+BEGIN_SRC clojure
(ns scripts.comments
  (:require [goog.dom :as dom]
            [goog.net.XhrIo :as xhr]
            [goog.Uri :as uri]
            [clojure.browser.repl :as repl]))

(defn format-comment [issue-id comment]
  (let [cuser (.. comment -user -login)
        cuserlink (str "https://www.github.com/" cuser)
        clink (str "https://github.com/cbilson/cbilson.github.com/issues/" issue-id "#issuecomment-" (.-id comment))
        cbody (.-body-html comment)
        cavatarlink (.. comment -user -avatar-url)
        cdate (.. js/Date (parse (.-created-at comment)) (toString "yyyy-MM-dd HH:mm:ss"))]
    (str "<div class='comment'><div class='commentheader'>"
         "<div class='commentgravatar'>"
         "<img src='" cavatarlink "' alt='' width='20' height='20'></img>"
         "</div>"
         "<a class='commentuser' href='" cuserlink "'>" cuser "</a>"
         "on <a class='commentdate' href='" clink "'>" cdate "</a>"
         "said: <div class='commentbody'>" cbody "</div>"
         "</div>")))

(defn show-comments [comments]
  (->> comments
       (map (partial format-comment (.-id comments)))
       (map dom/htmlToDocumentFragment)
       (map (partial dom/appendChild (dom/getElement "comments")))))

(defn send [url callback headers content timeout]
  (let [uri (goog.Uri. url)
        headers (clj->js headers)
        content (clj->js content)]
    (xhr/send uri callback "GET" content headers timeout)))

(defn ^:export load-comments [issue-id]
  (let [url (str "https://api.github.com/repos/cbilson/cbilson.github.com/issues/"
                 issue-id "/comments")
        uri (goog.Uri. url)]
    (send uri show-comments {"Accept" "application/vnd.github.full+json"} nil 30000)))

(repl/connect "http://localhost:9000/repl")
#+END_SRC

Since the script is no longer in the page, we can't inject the front
matter through the template like we did in the javascript version. We
need the page to pass this in:

#+BEGIN_EXAMPLE
<script type='text/javascript'>
scripts.comments.load_comments({% raw %}{{page.commentIssueId}}{% endraw %}));
</script>
#+END_EXAMPLE

That's pretty close to a line for line translation. I can get rid of
jQuery/Zepto and a few other dependencies, but not datejs and if you
looked at the javascript that is generated for this little tiny bit
of clojurescript, you might get the feeling that I have traded a
small elephant for a whale, in terms of code size.

But who cares. Let's geek out some more.

** Dialing up the geek

There are a lot of strings in the clojure script above. What are
those strings, anyway? Aren't they just data? The strings are
completely hiding the structure of the data. Why don't we ditch them
for clojure data structures, and write a function that transforms
them into a DOM fragment to append to the doc...

TODO: put an example here

There are actually great libraries available to do a lot of this for
us, like dommy[fn:3] or enfocus[fn:4]. I would probably use one of
those if I were doing this for work, but here it would be more fun to
focus on core clojurescript stuff.

** Dynamic Comments

What if I leave the page open for days and there are new
comments. Let's add something to poll the comments on github
periodically to check for changes.

TODO: Github API Limits

TODO: add core.async dependency

TODO: code

** Just in Time

When I leave the page open for days, I don't actually care about
comments most of the time. When I really care about them is when I am
about to make a comment myself. If I am in the middle of typing a
comment, it would be better if it checked for updates more frequently.

TODO: code

* Conclusion

Adding clojurescript to a static web site is fun and opens the mind
up to lots of possibilities for using clojurescript in more practical
settings. core.async in particular is a really neat library that
takes event driven browser-apps up to the next level.

* Further Research

It would be fun to find a project to use with core.async and web
sockets.

* Footnotes

[fn:1] https://github.com/cbilson/cbilson.github.com/commit/fbd1f074ee4ca36d56dbadcc96b4e61878496bc2

[fn:2] https://github.com/yoshinari-nomura/org-octopress.git

[fn:3] https://github.com/Prismatic/dommy

[fn:4] https://github.com/ckirkendall/enfocus



